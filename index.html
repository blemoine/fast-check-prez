<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Test de propriétés avec Fast-Check</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <style>
      pre {
        width: 95%;
      }
      .reveal pre code {
        max-height: 600px;
      }
      .warning-box {
        background-color: #fff3cd;
        padding: 10px 5px;
        border: 2px solid #ffe69c;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Les tests de propriétés</h1>

          <img
            src="img/logo.png"
            alt="logo de fast-check "
            style="position: relative; left: 50px"
          />
        </section>
        <section>
          <h2>Qui suis je?</h2>
          <ul
            style="
              display: inline-block;
              width: 700px;
              vertical-align: top;
              position: relative;
            "
          >
            <li>Benoît Lemoine</li>
            <li>
              Développeur Fullstack<br />(TS, Scala, Rust, ...) <br />
              Intérêt pour la programmation fonctionnelle et les systèmes de
              type
              <br />
            </li>
            <li>
              Travaille chez <a href="https://www.busbud.com">Busbud</a>; on
              recrute&nbsp;!
            </li>
            <li>
              <a href="https://lemoine-benoit.medium.com/"
                >https://lemoine-benoit.medium.com/</a
              >
            </li>

            <li>
              <a href="https://twitter.com/benoit_lemoine">@benoit_lemoine</a>
            </li>
          </ul>
          <img
            style="display: inline-block; width: 200px; vertical-align: top"
            src="img/Moloch.png"
            alt="Le plus bel animal du monde"
          />
        </section>

        <section>
          <h2>Les limites des tests basés sur l'exemple</h2>
        </section>

        <section>
          <h2>Story</h2>
          <p class="fragment">
            En tant que client, je veux payer 0.9% du prix total en frais
            d'envoi sauf si les frais sont supérieurs ou égaux à un seuil
            configurable, auquel cas, ils sont gratuits
          </p>
          <ul style="font-size: 90%">
            <li class="fragment">Les frais sont 0$ si le prix total est 0$</li>
            <li class="fragment">Les frais sont 0$ si le seuil est 0$</li>
            <li class="fragment">
              Les frais sont 9$ si le prix total est 1000$ et le seuil 10$
            </li>
            <li class="fragment">
              Les frais sont 0$ si le prix total est 1000$ et le seuil 9$
            </li>
            <li class="fragment">
              Les frais sont 0$ si le prix total est 1000$ et le seuil 7$
            </li>
          </ul>
        </section>

        <section>
          <h2>Tests</h2>
          <pre><code data-trim class="typescript">
describe("getFees", () => {
  it("should return 0 if the price is 0", () => {
    expect(getFees(0, 10)).toStrictEqual(0);
  });
  it("should return 0 if the freeThreshold is 0", () => {
    expect(getFees(100, 0)).toStrictEqual(0);
  });
  it("should return 0.9% of the price if the fees are below the threshold", () => {
    expect(getFees(1000, 10)).toStrictEqual(9);
  });
  it("should return 0 if the fees are equal to the threshold", () => {
    expect(getFees(1000, 9)).toStrictEqual(0);
  });
  it("should return 0 if the fees are above to the threshold", () => {
    expect(getFees(1000, 7)).toStrictEqual(0);
  });
});
				</code></pre>
        </section>

        <section>
          <h2>Implementation</h2>
          <pre><code class="typescript" data-trim>
export function getFees(price: number,
                        threshold: number): number {
  const shippingFeesRate = 0.009;
  const shippingFees = shippingFeesRate * price;
  return shippingFees >= threshold ? 0 : shippingFees;
}
					</code></pre>
        </section>

        <section>
          <h2>Result</h2>
          <pre><code data-trim class="haskell">
Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        2.618 s                  
              </code></pre>
        </section>

        <section>
          <h2>La feature part en prod...</h2>
          <h2 class="fragment">Mais bug en production...</h2>
          <p class="fragment">
            Le prix total était de 3000$ et le seuil de 27$, et l'utilisateur a
            du payer des frais d'expédition&nbsp;!
          </p>
        </section>

        <section>
          <h2>Test</h2>
          <pre><code data-trim class="typescript">
test("return 0 if it the fees are equal to the threshold", () => {
  expect(getFees(3000, 27)).toStrictEqual(0);
});
		  </code></pre>
          <pre class="fragment"><code data-trim class="typescript">
getFees › return 0 if the fees are equal to the threshold

expect(received).toStrictEqual(expected) // deep equality

Expected: 0
Received: 26.999999999999996
			</code></pre>
        </section>

        <section>
          <h2>Analyse</h2>
          <ul>
            <li>
              <code>getFees</code> fonctionne dans <em>presque</em> tous les cas
            </li>
            <li class="fragment">
              Impossible de tester <em>tous</em> les cas (ici, nécessiterait
              2<sup>64</sup> * 2<sup>64</sup> tests)
            </li>
          </ul>
        </section>

        <section>
          <h2>
            Comment trouver ces erreurs <em>avant</em> qu'elles n'arrivent en
            production
          </h2>
          <p class="fragment">Il faut trouver les examples invalides</p>
        </section>

        <section>
          <h2>Comment trouver ces exemples&nbsp;?</h2>
          <ul>
            <li class="fragment">Génération aléatoire des valeurs de test</li>
            <li class="fragment">
              Exécution des tests un grand nombre de fois
            </li>
          </ul>
        </section>

        <section>
          <h2>Les tests de propriétés - Property based testing</h2>
          <h3>Fast-Check</h3>
          <a href="https://github.com/dubzzz/fast-check"
            >https://github.com/dubzzz/fast-check</a
          >
        </section>

        <section>
          <h2>1<sup>er</sup> Exemple</h2>
          <pre><code data-trim class="typescript">
test("return 0 if the threshold is 0", () => {
    fc.assert(
      fc.property(fc.nat(), (price: number) => {
        expect(getFees(price, 0)).toStrictEqual(0);
      })
    );
});
			  </code></pre>
          <p class="fragment">
            Quelque soit <code>price</code> un entier naturel,
            <code>getFees(price, 0)</code> est toujours égal à 0
          </p>
        </section>

        <section>
          <h2>2<sup>eme</sup> example</h2>
          <pre><code data-trim class="typescript">
test("return something smaller than the threshold", () => {
  fc.assert(
    fc.property(fc.nat(), fc.nat(),
      (price: number, threshold: number) => {
        expect(getFees(price, threshold)).toBeLessThanOrEqual(
          threshold
        );
    })
  );
});
			  </code></pre>
          <p class="fragment">
            Quelque soit <code>price</code> et <code>threshold</code> 2 entiers
            naturel, <code>getFees(price, threshold)</code> est toujours
            inférieur à threshold
          </p>
        </section>

        <section>
          <h2>Autre example</h2>
          <pre><code data-trim class="typescript">
test('trim should return a smaller string', () => {
  fc.assert(
    fc.property(fc.string(), (str) => {
      expect(str.trim().length)
        .toBeLessThanOrEqual(str.length)
    })
  );
})
            </code></pre>
          <p class="fragment">
            Quelque soit <code>str</code> une <code>string</code>,<br />
            <code>str.trim()</code> est toujours plus court que <code>str</code>
          </p>
        </section>

        <section>
          <h2>Arbitraries</h2>
          <ul>
            <li class="fragment">
              fc.nat(), fc.integer(), fc.float(), fc.double(), etc.
            </li>
            <li class="fragment">
              fc.string(), fc.asciiString(), fc.unicodeString(), etc.
            </li>
            <li class="fragment">
              fc.ipV4(), fc.uuid(), fc.emailAddress(), etc.
            </li>
            <li class="fragment">
              fc.array(anotherArbitrary), fc.func(anotherArbitrary), etc.
            </li>
          </ul>
        </section>

        <section>
          <h2>Custom Arbitrary</h2>
          <pre><code data-trim class="typescript">
type User = {id: string, age: number, email: string | null };

const arbUser: Arbitrary&lt;User> = fc.record({
  id: fc.uuid(),
  age: fc.nat({max: 99}),
  email: fc.option(fc.emailAddress())
});

it('supports custom arbitrary', () => {
	fc.assert(fc.property(arbUser, (user:User) =>
      /* test something */));
});
			  </code></pre>
        </section>

        <section>
          <h2>Range?</h2>
          <p>
            On veut arbitrary qui genere une paire d'entier naturel, le 2eme
            strictement plus grand que le premier
          </p>
          <ul>
            <li><code>[1, 3]</code></li>
            <li><code>[1748, 1749]</code></li>
            <li><code>[2, 97381273]</code></li>
            <li>etc.</li>
          </ul>
        </section>

        <section>
          <h2>Range?</h2>
          <h3>Map</h3>
          <pre><code data-trim class="typescript">
const arbRange = fc.nat().map(min => [min, min + 10])
          </code></pre>
        </section>

        <section>
          <h2>Range?</h2>
          <h3>Filter</h3>
          <pre><code data-trim class="typescript">
const arbRange = fc.tuple(fc.nat(), fc.nat())
              .filter(([min, max]) => max > min)
              </code></pre>
          <p class="fragment warning-box">
            /!\ Si trop de cas sont filtrés, fast-check peut échouer car il ne
            trouve pas assez de valeur pour exécuter les tests
          </p>
        </section>
        <section>
          <h2>Range?</h2>
          <h3>Chain</h3>
          <pre><code data-trim class="typescript">
const arbRange = fc.nat().chain(min => {
  return fc.tuple(fc.constant(min), fc.integer({min})
})
              </code></pre>
        </section>

        <section>
          <h2>Shrinking</h2>
          <p>Chercher le cas d'erreur minimum</p>
          <pre><code class="typescript" data-trim>
export function getFees(price: number,
                        threshold: number): number {
  const shippingFeesRate = 0.009;
  const shippingFees = shippingFeesRate * price;
  return shippingFees >= threshold ? 0 : shippingFees;
}
					</code></pre>
          <pre><code data-trim class="typescript">
fc.assert(
  fc.property(fc.nat(), (n) => {
    expect(getFees(n * 1000, n * 9)).toStrictEqual(0);
  })
);
</code></pre>
        </section>

        <section>
          <h2>Shrinking</h2>
          <pre><code data-trim>
Property failed after 2 tests
{ seed: 1246452816, path: "1:1:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:1", endOnFailure: true }
Counterexample: [6]
Shrunk 26 time(s)
Got error: Error: expect(received).toStrictEqual(expected) // deep equality

Expected: 0
Received: 53.99999999999999
              </code></pre>
        </section>

        <section>
          <h2>Seeds / replay</h2>
          <pre><code data-trim class="typescript">
 fc.assert(
  fc.property(fc.nat(), (n) => {
    expect(getFees(n * 1000, n * 9)).toStrictEqual(0);
  }),
  { seed: 1246452816,
    path: "1:1:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:1",
    endOnFailure: true }
);
</code></pre>
        </section>

        <section>
          <h2>/!\ Ne pas copier/coller l'implémentation dans les tests</h2>
          <pre><code class="typescript" data-trim>
export function getFees(price: number,
                        threshold: number): number {
  const shippingFeesRate = 0.009;
  const shippingFees = shippingFeesRate * price;
  return shippingFees >= threshold ? 0 : shippingFees;
}
					</code></pre>
          <pre><code data-trim class="typescript">
 // N'échoue jamais
fc.assert(
  fc.property(fc.nat(), (n) => {
    expect(getFees(n , n * 0.009)).toStrictEqual(0);
  })
);
</code></pre>
        </section>

        <section>
          <h2>Quelques cas d'utilisation</h2>
        </section>

        <section>
          <h3>Serialization / Deserialization</h3>
          <pre><code data-trim class="typescript">
type Permission = {
  read:boolean, write: boolean, execution: boolean
};
const ser = ({read, write, execution}: Permission): number =>
  (read ? 0b100 :0) + (write? 0b10 :0) + (execution? 1 :0);

const deser = (permission: number): Permission => ({
  read: !(permission & 0b100),
  write: !(permission & 0b10),
  execution: !(permission & 1)
})

		  </code></pre>

          <pre><code data-trim class="typescript">
test('ser and deser should be inverse of each other', () => {
	fc.assert(fc.property(fc.nat({max: 7}), (n) =>
		expect(ser(deser(n)).toStrictEqual(n)
	))
})
			</code></pre>
        </section>

        <section>
          <h3>Metamorphic Tests</h3>
          <pre><code data-trim class="typescript">
function customSort(arr: number[]): number[] {
	return [...arr].sort((a,b) => b - a);
}
			</code></pre>
          <pre><code data-trim class="typescript">
test('custom sort should be stable', () => {
  fc.assert(fc.property(fc.array(fc.number()), (arr) => {
    const shuffledArr = [...arr]
              .sort(() => 0.5 - Math.random());
    expect(customSort(arr)).toStrictEqual(
      customSort(shuffledArr)
    })
  ))
})
			</code></pre>
        </section>

        <section>
          <h3>Propriétés Algébriques</h3>
          <pre><code data-trim class="typescript">
test('Array forms a functor', () => {
  fc.assert(
    fc.property(fc.array(fc.number()), fc.func(fc.string()),
    fc.func(fc.boolean), (arr, f1, f2) => {
      expect(arr.map(f1).map(f2)).toStrictEqual(
        arr.map(x => f2(f1(x)))
      )
  });
})
            </code></pre>
        </section>

        <section>
          <h3>Générer un objet de domaine</h3>
          <pre><code data-trim class="typescript">
type UserCreateInput = { age: number, name: string }
const arbUserCreateInput: Arbitrary&lt;UserCreateInput> =
  fc.record({
    age: fc.nat({ max: 150 }),
    name: fc.string({ maxLength: 100 })
  });

it('should persist the user in the database', () => {
  return fc.assert(
   fc.asyncProperty(arbUserCreateInput, async (user) => {
     expect(await saveUser(user)).toHaveProperty('id');
  }, { numRuns:1 })
})
        </code></pre>
        </section>

        <section>
          <h2>Conclusion</h2>
          <ul>
            <li>Utile dans le vrai monde (jest, javascript-algorithm, etc.)</li>
            <li>Mais ralenti les tests - à utiliser avec parcimonie</li>
            <li>
              Existe dans d'autre technologies&nbsp;: scalacheck (scala),
              hypothesis (python), quickcheck (haskell), propcheck (ruby), etc.
            </li>
          </ul>
        </section>

        <section>
          <h2>Questions&nbsp;?</h2>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
